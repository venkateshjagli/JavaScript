************JavaScript Documentions**************
What is JavaScript?

	a. JavaScript was initially created to “make web pages alive”.
	b. Javascript (JS) is a scripting languages, primarily used on the Web. It is used to enhance HTML pages and is commonly found embedded in HTML code. JavaScript is an interpreted language. 
		The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
	c. JavaScript became a fully independent language with its own specification called ECMAScript.
	d. JavaScript can be run on any device that has a special program called the JavaScript engine.
	e. JavaScript was initially created as a browser-only language, but is now used in many other environments as well.
	f. JavaScript has a unique position as the most widely-adopted browser language with full integration with HTML/CSS.
	g. There are many languages that get “transpiled” to JavaScript and provide certain features. 
	h. The ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.

References : 
https://developer.mozilla.org/en-US/docs/Web/JavaScript
https://javascript.info/

The JavaScript engine.

JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.

Different engines :
	a. V8 – Chrome and Opera.
	b. SpiderMonkey – Firefox.
	c. Trident, Chakra - IE - Internet Explorer
	d. ChakraCore - MS Edge 
	e. Nitro, SquirrelFish - Safari

How do engines work?
	a. The engine (embedded if it’s a browser) reads (“parses”) the script.
	b. it converts (“compiles”) the script to the machine language.
	c. the machine code runs, pretty fast.

How Javascript works in browser ?
JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.

	a. Add new HTML to the page, change the existing content, modify styles.
	b. React to user actions, run on mouse clicks, pointer movements, key presses.
	c.Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
	d. Get and set cookies, ask questions to the visitor, show messages.
	e. Remember the data on the client-side (“local storage”).

What makes JavaScript unique?
	a. Full integration with HTML/CSS.
	b. Simple things are done simply.
	c. Support by all major browsers and enabled by default.

Languages over JavaScript ?
Convert(transpiled) any other languages to JavaScript like TypeScript which can be written in TypeScript Language [Microsoft].
 	
Code editors (IDE - Integrated Development Environment)?
	a. IDE
		1. Visual Studio Code (cross-platform, free).
		2. WebStorm (cross-platform, paid).
	b. Lightweight
		1. Atom (cross-platform, free).
		2. Visual Studio Code (cross-platform, free).
		3. Sublime Text (cross-platform, shareware).
		4. Notepad++ (Windows, free).
		5. Vim and Emacs are also cool if you know how to use them.

Developer console? Learn how debug code and contro keys to debug and check the data in console

Script Tag :
JavaScript programs can be inserted into any part of an HTML document with the help of the <script> tag.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.

		a. <script src="/path/to/script.js"></script>
		
		b. <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>
		
		d. Multitag script
			<script src="/js/script1.js"></script>
			<script src="/js/script2.js"></script>

		e. A single <script> tag can’t have both the src attribute and code inside.
				This won’t work:
				/*
						   <script src="file.js">
							alert(1); // the content is ignored, because src is set
							</script>
				*/
		f. We must choose either an external <script src="…"> or a regular <script> with code.
				The example above can be split into two scripts to work:
				/*
					<script src="file.js"></script>

					<script>
					alert(1);
					</script>
				*/
		g. The type and language attributes are not required. Older versins of HTML uses <script type='text/javascript' />, no more of this in newer versins of HTML [HTML5]
		h. We can use a <script> tag to add JavaScript code to a page.
		i. A script in an external file can be inserted with <script src="path/to/script.js"></script>
		h. As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files. The benefit of a separate file is that the browser will download it and store it in its cache.
			Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once. That reduces traffic and makes pages faster.

Coding Standards ?
We recommend putting semicolons between statements even if they are separated by newlines. 
The error in the no-semicolon variant occurs because JavaScript does not assume a semicolon before square brackets [...].

Differences between strict mode and the “default” mode ?
1. The "use strict" directive switches the engine to the “modern” mode, changing the behavior of some built-in features.
2. Strict mode is enabled by placing "use strict" at the top of a script or function. Several language features, like “classes” and “modules”, enable strict mode automatically.
3. Strict mode is supported by all modern browsers.
4. We recommended always starting scripts with "use strict". 

Reserved Words : let, var, const,return, for, if, do, while, switch, function, etc

Variable
1. Variable is a “named storage” for data.
2. The name must contain only letters, digits, or the symbols $ and _.
3. The first character must not be a digit.
	Examples :  
			let userName;
			let test123;
4. Variables named apple and AppLE are two different variables.
5. Non-Latin letters are allowed, but not recommended
	a. let – is a modern variable declaration.
		let message = 'Hello!'; 
	b.var – is an old-school variable declaration.
		var message = 'Hello!'; 
	c. const – is like let, but the value of the variable can’t be changed.
		const COLOR_RED = "#F00";

Data types
1. A variable in JavaScript can contain any data. A variable can at one moment be a string and at another be a number. Programming languages that allow such things are called “dynamically typed”
Example : 
	// no error
	let message = "hello";
	message = 123456;
2. There are seven basic data types in JavaScript.
->The number type represents both integer and floating point numbers.
*A string
->In JavaScript, there are 3 types of quotes.
Double quotes: "Hello".
Single quotes: 'Hello'.
Backticks: `Hello`.
->Double and single quotes are “simple” quotes. There’s no difference between them in JavaScript.
->Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in ${…}, for example:
12).Conditional operators: if, '?' -> or Ternary operators
->If Condition 
We can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.
The if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.
Your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute.
->else Condition
The if statement may contain an optional “else” block. It executes when the condition is false.
->Boolean conversion
A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
13).Logic`al operators
->There are three logical operators in JavaScript: || (OR), && (AND), ! (NOT).
Can be applied to values of any type, not only boolean. 
->"OR"
The “OR” operator is represented with two vertical line symbols:
In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are true, it returns true, otherwise it returns false.
The result is always "true" except for the case when both operands are "false".
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were false), returns the last operand.
->&& (AND)
The AND operator is represented with two ampersands &&:
AND returns true if both operands are truthy and false otherwise:
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were truthy), returns the last operand.
-> ! NOT
The boolean NOT operator is represented with an exclamation sign !.
Converts the operand to boolean type: true/false.
14).Loops
outputting goods from a list one after another or just running the same code for each number from 1 to 10.
->While Loop
Loops are a way to repeat the same code multiple times.
While the condition is truthy, the code from the loop body is executed.
Any expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by while.
->Do While Loop
The condition check can be moved below the loop body using the do..while syntax:
The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.
This form of syntax should only be used when you want the body of the loop to execute at least once regardless of the condition being truthy. Usually, the other form is preferred: while(…) {…}.
->For Loop
The loop below runs alert(i) for i from 0 up to (but not including) 3:
That is, begin executes once, and then it iterates: after each condition test, body and step are executed.
->For In Loop

->For Of Loop

15).Switch statement
A switch statement can replace multiple if checks.
It gives a more descriptive way to compare a value with multiple variants.
The switch has one or more case blocks and an optional default.
If no case is matched then the default code is executed (if it exists).
16).Function
Functions are the main “building blocks” of the program. They allow the code to be called many times without repetition.
This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.
->Local variables
A variable declared inside a function is only visible inside that function.
->Global variables
Variables declared outside of any function, such as the outer userName in the code above, are called global.
Global variables are visible from any function (unless shadowed by locals).
->Parameters
We can pass arbitrary data to functions using parameters (also called function arguments) .
->Returning a value
A function can return a value back into the calling code as the result.
It is possible to use return without a value. That causes the function to exit immediately.
A function with an empty return or without it returns undefined
If a function does not return a value, it is the same as if it returns undefined:
->Why is there a semicolon at the end?
why does Function Expression have a semicolon ; at the end, but Function Declaration does not:
	/*
	function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
*/
->There’s no need for ; at the end of code blocks and syntax structures that use them like if { ... }, for { }, function f { } etc.
->A Function Expression is used inside the statement: let sayHi = ...;, as a value. It’s not a code block, but rather an assignment.
The semicolon ; is recommended at the end of statements, no matter what the value is. So the semicolon here is not related to the Function Expression itself, it just terminates the statement.
->Callback functions

17).Strings
In JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.
17).Strings
In JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.
Strings can be enclosed within either single quotes, double quotes or backticks:
18).Array
Objects allow you to store keyed collections of values.
arr.push(...items) – adds items to the end,
arr.pop() – extracts an item from the end,
arr.shift() – extracts an item from the beginning,
arr.unshift(...items) – adds items to the beginning.
-->Array Methods
A cheat sheet of array methods:
To add/remove elements:
push(...items) – adds items to the end,
pop() – extracts an item from the end,
shift() – extracts an item from the beginning,
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – at index pos delete deleteCount elements and insert items.
slice(start, end) – creates a new array, copies elements from position start till end (not inclusive) into it.
concat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.
To search among elements:

indexOf/lastIndexOf(item, pos) – look for item starting from position pos, return the index or -1 if not found.
includes(value) – returns true if the array has value, otherwise false.
find/filter(func) – filter elements through the function, return first/all values that make it return true.
findIndex is like find, but returns the index instead of a value.
To iterate over elements:

forEach(func) – calls func for every element, does not return anything.
To transform the array:

map(func) – creates a new array from results of calling func for every element.
sort(func) – sorts the array in-place, then returns it.
reverse() – reverses the array in-place, then returns it.
split/join – convert a string to array and back.
reduce(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.
Additionally:

Array.isArray(arr) checks arr for being an array.

19).Map and Set
Now we’ve learned about the following complex data structures:

Objects for storing keyed collections.
Arrays for storing ordered collections.
But that’s not enough for real life. That’s why Map and Set also exist.

->Map
Map is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.

Methods and properties are:

new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the value by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.

->Iteration over Map
For looping over a map, there are 3 methods:

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.


->Set
A Set is a special type collection – “set of values” (without keys), where each value may occur only once.

Its main methods are:

new Set(iterable) – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.
set.add(value) – adds a value, returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

20).WeakMap and WeakSet
As we know from the chapter Garbage collection, JavaScript engine stores a value in memory while it is reachable 
(and can potentially be used).
->WeakMap
The first difference from Map is that WeakMap keys must be objects, not primitive values:
Compare it with the regular Map example above. Now if john only exists as the key of WeakMap – it will be automatically deleted from the map (and memory).
WeakMap does not support iteration and methods keys(), values(), entries(), so there’s no way to get all keys or values from it.
WeakMap has only the following methods:
weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)

->WeakSet
WeakSet behaves similarly:
It is analogous to Set, but we may only add objects to WeakSet (not primitives).
An object exists in the set while it is reachable from somewhere else.
Like Set, it supports add, has and delete, but not size, keys() and no iterations.

21).Object.keys, values, entries
For plain objects, the following methods are available:

Object.keys(obj) – returns an array of keys.
Object.values(obj) – returns an array of values.
Object.entries(obj) – returns an array of [key, value] pairs.

21).Date and time
Let’s meet a new built-in object: Date. It stores the date, time and provides methods for date/time management.
we can use it to store creation/modification times, to measure time, or just to print out the current date.
Creation
Greenwich Mean Time (GMT) is often interchanged or confused with Coordinated Universal Time (UTC). But GMT is a time zone and UTC is a time standard.
 The Royal Observatory in the UK. The Royal Observatory in Greenwich, London, United Kingdom.
To create a new Date object call new Date() with one of the following arguments:
->new Date()
Without arguments – create a Date object for the current date and time:
->new Date(milliseconds)
Create a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.
->new Date(datestring)
If there is a single argument, and it’s a string, then it is parsed automatically. The algorithm is the same as Date.parse uses, we’ll cover it later.
->Setting date components
->The following methods allow to set date/time components:
setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)
->new Date(year, month, date, hours, minutes, seconds, ms)
Create the date with the given components in the local time zone. Only the first two arguments are obligatory.
The year must have 4 digits: 2013 is okay, 98 is not.
The month count starts with 0 (Jan), up to 11 (Dec).
The date parameter is actually the day of month, if absent then 1 is assumed.
If hours/minutes/seconds/ms is absent, they are assumed to be equal 0.
/*
new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // the same, hours etc are 0 by default
*/
The minimal precision is 1 ms (1/1000 sec):.
->Access date components
There are methods to access the year, month and so on from the Date object:
getFullYear()
Get the year (4 digits)
getMonth()
Get the month, from 0 to 11.
getDate()
Get the day of month, from 1 to 31, the name of the method does look a little bit strange.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Get the corresponding time components.
->getDay()
Get the day of week, from 0 (Sunday) to 6 (Saturday). The first day is always Sunday, in some countries that’s not so, but can’t be changed.
->Besides the given methods, there are two special ones that do not have a UTC-variant:
->getTime()
Returns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.
->getTimezoneOffset()
Returns the difference between the local time zone and UTC, in minutes:
/*
// if you are in timezone UTC-1, outputs 60
// if you are in timezone UTC+3, outputs -180
alert( new Date().getTimezoneOffset() );
*/
->Autocorrection
The autocorrection is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.
/*
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...is 1st Feb 2013!
*/
->Date.now()
If we only want to measure time, we don’t need the Date object.
There’s a special method Date.now() that returns the current timestamp.
It is semantically equivalent to new Date().getTime(), but it doesn’t create an intermediate Date object. So it’s faster and doesn’t put pressure on garbage collection.
It is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.
