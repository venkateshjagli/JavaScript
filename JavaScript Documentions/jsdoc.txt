************JavaScript Documentions**************
What is JavaScript?

	a. JavaScript was initially created to “make web pages alive”.
	b. Javascript (JS) is a scripting languages, primarily used on the Web. It is used to enhance HTML pages and is commonly found embedded in HTML code. JavaScript is an interpreted language. 
		The programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.
	c. JavaScript became a fully independent language with its own specification called ECMAScript.
	d. JavaScript can be run on any device that has a special program called the JavaScript engine.
	e. JavaScript was initially created as a browser-only language, but is now used in many other environments as well.
	f. JavaScript has a unique position as the most widely-adopted browser language with full integration with HTML/CSS.
	g. There are many languages that get “transpiled” to JavaScript and provide certain features. 
	h. The ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.

References : 
https://developer.mozilla.org/en-US/docs/Web/JavaScript
https://javascript.info/

The JavaScript engine.

JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.
The browser has an embedded engine sometimes called a “JavaScript virtual machine”.

Different engines :
	a. V8 – Chrome and Opera.
	b. SpiderMonkey – Firefox.
	c. Trident, Chakra - IE - Internet Explorer
	d. ChakraCore - MS Edge 
	e. Nitro, SquirrelFish - Safari

How do engines work?
	a. The engine (embedded if it’s a browser) reads (“parses”) the script.
	b. it converts (“compiles”) the script to the machine language.
	c. the machine code runs, pretty fast.

How Javascript works in browser ?
JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.

	a. Add new HTML to the page, change the existing content, modify styles.
	b. React to user actions, run on mouse clicks, pointer movements, key presses.
	c.Send requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).
	d. Get and set cookies, ask questions to the visitor, show messages.
	e. Remember the data on the client-side (“local storage”).

What makes JavaScript unique?
	a. Full integration with HTML/CSS.
	b. Simple things are done simply.
	c. Support by all major browsers and enabled by default.

Languages over JavaScript ?
Convert(transpiled) any other languages to JavaScript like TypeScript which can be written in TypeScript Language [Microsoft].
 	
Code editors (IDE - Integrated Development Environment)?
	a. IDE
		1. Visual Studio Code (cross-platform, free).
		2. WebStorm (cross-platform, paid).
	b. Lightweight
		1. Atom (cross-platform, free).
		2. Visual Studio Code (cross-platform, free).
		3. Sublime Text (cross-platform, shareware).
		4. Notepad++ (Windows, free).
		5. Vim and Emacs are also cool if you know how to use them.

Developer console? Learn how debug code and contro keys to debug and check the data in console

Script Tag :
JavaScript programs can be inserted into any part of an HTML document with the help of the <script> tag.
The <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.

		a. <script src="/path/to/script.js"></script>
		
		b. <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>
		
		d. Multitag script
			<script src="/js/script1.js"></script>
			<script src="/js/script2.js"></script>

		e. A single <script> tag can’t have both the src attribute and code inside.
				This won’t work:
				/*
						   <script src="file.js">
							alert(1); // the content is ignored, because src is set
							</script>
				*/
		f. We must choose either an external <script src="…"> or a regular <script> with code.
				The example above can be split into two scripts to work:
				/*
					<script src="file.js"></script>

					<script>
					alert(1);
					</script>
				*/
		g. The type and language attributes are not required. Older versins of HTML uses <script type='text/javascript' />, no more of this in newer versins of HTML [HTML5]
		h. We can use a <script> tag to add JavaScript code to a page.
		i. A script in an external file can be inserted with <script src="path/to/script.js"></script>
		h. As a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files. The benefit of a separate file is that the browser will download it and store it in its cache.
			Other pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once. That reduces traffic and makes pages faster.

Coding Standards ?
We recommend putting semicolons between statements even if they are separated by newlines. 
The error in the no-semicolon variant occurs because JavaScript does not assume a semicolon before square brackets [...].

Differences between strict mode and the “default” mode ?
1. The "use strict" directive switches the engine to the “modern” mode, changing the behavior of some built-in features.
2. Strict mode is enabled by placing "use strict" at the top of a script or function. Several language features, like “classes” and “modules”, enable strict mode automatically.
3. Strict mode is supported by all modern browsers.
4. We recommended always starting scripts with "use strict". 

Reserved Words : let, var, const,return, for, if, do, while, switch, function, etc

Variable
1. Variable is a “named storage” for data.
2. The name must contain only letters, digits, or the symbols $ and _.
3. The first character must not be a digit.
	Examples :  
			let userName;
			let test123;
4. Variables named apple and AppLE are two different variables.
5. Non-Latin letters are allowed, but not recommended
	a. let – is a modern variable declaration.
		let message = 'Hello!'; 
	b.var – is an old-school variable declaration.
		var message = 'Hello!'; 
		If a code block is inside a function, then var becomes a function-level variable:
		var variables have no block scope, they are visible minimum at the function level.
		var declarations are processed at function start (script start for globals).
	c. const – is like let, but the value of the variable can’t be changed.
		const COLOR_RED = "#F00";

Data types
1. A variable in JavaScript can contain any data. A variable can at one moment be a string and at another be a number. Programming languages that allow such things are called “dynamically typed”
Example : 
	// no error
	let message = "hello";
	message = 123456;
2. There are seven basic data types in JavaScript.
->The number type represents both integer and floating point numbers.
*A string
->In JavaScript, there are 3 types of quotes.
Double quotes: "Hello".
Single quotes: 'Hello'.
Backticks: `Hello`.
->Double and single quotes are “simple” quotes. There’s no difference between them in JavaScript.
->Backticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in ${…}, for example:
12).Conditional operators: if, '?' -> or Ternary operators
->If Condition 
We can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.
The if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.
Your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute.
->else Condition
The if statement may contain an optional “else” block. It executes when the condition is false.
->Boolean conversion
A number 0, an empty string "", null, undefined, and NaN all become false. Because of that they are called “falsy” values.
13).Logic`al operators
->There are three logical operators in JavaScript: || (OR), && (AND), ! (NOT).
Can be applied to values of any type, not only boolean. 
->"OR"
The “OR” operator is represented with two vertical line symbols:
In classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are true, it returns true, otherwise it returns false.
The result is always "true" except for the case when both operands are "false".
For each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were false), returns the last operand.
->&& (AND)
The AND operator is represented with two ampersands &&:
AND returns true if both operands are truthy and false otherwise:
For each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.
If all operands have been evaluated (i.e. all were truthy), returns the last operand.
-> ! NOT
The boolean NOT operator is represented with an exclamation sign !.
Converts the operand to boolean type: true/false.
14).Loops
outputting goods from a list one after another or just running the same code for each number from 1 to 10.
->While Loop
Loops are a way to repeat the same code multiple times.
While the condition is truthy, the code from the loop body is executed.
Any expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by while.
->Do While Loop
The condition check can be moved below the loop body using the do..while syntax:
The loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.
This form of syntax should only be used when you want the body of the loop to execute at least once regardless of the condition being truthy. Usually, the other form is preferred: while(…) {…}.
->For Loop
The loop below runs alert(i) for i from 0 up to (but not including) 3:
That is, begin executes once, and then it iterates: after each condition test, body and step are executed.
->For In Loop

->For Of Loop

15).Switch statement
A switch statement can replace multiple if checks.
It gives a more descriptive way to compare a value with multiple variants.
The switch has one or more case blocks and an optional default.
If no case is matched then the default code is executed (if it exists).
16).Function
Functions are the main “building blocks” of the program. They allow the code to be called many times without repetition.
This example clearly demonstrates one of the main purposes of functions: to avoid code duplication.
->Local variables
A variable declared inside a function is only visible inside that function.
->Global variables
Variables declared outside of any function, such as the outer userName in the code above, are called global.
Global variables are visible from any function (unless shadowed by locals).
->Parameters
We can pass arbitrary data to functions using parameters (also called function arguments) .
->Returning a value
A function can return a value back into the calling code as the result.
It is possible to use return without a value. That causes the function to exit immediately.
A function with an empty return or without it returns undefined
If a function does not return a value, it is the same as if it returns undefined:
->Why is there a semicolon at the end?
why does Function Expression have a semicolon ; at the end, but Function Declaration does not:
	/*
	function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
*/
->There’s no need for ; at the end of code blocks and syntax structures that use them like if { ... }, for { }, function f { } etc.
->A Function Expression is used inside the statement: let sayHi = ...;, as a value. It’s not a code block, but rather an assignment.
The semicolon ; is recommended at the end of statements, no matter what the value is. So the semicolon here is not related to the Function Expression itself, it just terminates the statement.
->Callback functions

17).Strings
In JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.
17).Strings
In JavaScript, the textual data is stored as strings. There is no separate type for a single character.
The internal format for strings is always UTF-16, it is not tied to the page encoding.
Strings can be enclosed within either single quotes, double quotes or backticks:
18).Array
Objects allow you to store keyed collections of values.
arr.push(...items) – adds items to the end,
arr.pop() – extracts an item from the end,
arr.shift() – extracts an item from the beginning,
arr.unshift(...items) – adds items to the beginning.
-->Array Methods
A cheat sheet of array methods:
To add/remove elements:
push(...items) – adds items to the end,
pop() – extracts an item from the end,
shift() – extracts an item from the beginning,
unshift(...items) – adds items to the beginning.
splice(pos, deleteCount, ...items) – at index pos delete deleteCount elements and insert items.
slice(start, end) – creates a new array, copies elements from position start till end (not inclusive) into it.
concat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.
To search among elements:

indexOf/lastIndexOf(item, pos) – look for item starting from position pos, return the index or -1 if not found.
includes(value) – returns true if the array has value, otherwise false.
find/filter(func) – filter elements through the function, return first/all values that make it return true.
findIndex is like find, but returns the index instead of a value.
To iterate over elements:

forEach(func) – calls func for every element, does not return anything.
To transform the array:

map(func) – creates a new array from results of calling func for every element.
sort(func) – sorts the array in-place, then returns it.
reverse() – reverses the array in-place, then returns it.
split/join – convert a string to array and back.
reduce(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.
Additionally:

Array.isArray(arr) checks arr for being an array.

19).Map and Set
Now we’ve learned about the following complex data structures:

Objects for storing keyed collections.
Arrays for storing ordered collections.
But that’s not enough for real life. That’s why Map and Set also exist.

->Map
Map is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.

Methods and properties are:

new Map() – creates the map.
map.set(key, value) – stores the value by the key.
map.get(key) – returns the value by the key, undefined if key doesn’t exist in map.
map.has(key) – returns true if the key exists, false otherwise.
map.delete(key) – removes the value by the key.
map.clear() – removes everything from the map.
map.size – returns the current element count.

->Iteration over Map
For looping over a map, there are 3 methods:

map.keys() – returns an iterable for keys,
map.values() – returns an iterable for values,
map.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.


->Set
A Set is a special type collection – “set of values” (without keys), where each value may occur only once.

Its main methods are:

new Set(iterable) – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.
set.add(value) – adds a value, returns the set itself.
set.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.
set.has(value) – returns true if the value exists in the set, otherwise false.
set.clear() – removes everything from the set.
set.size – is the elements count.

20).WeakMap and WeakSet
As we know from the chapter Garbage collection, JavaScript engine stores a value in memory while it is reachable 
(and can potentially be used).
->WeakMap
The first difference from Map is that WeakMap keys must be objects, not primitive values:
Compare it with the regular Map example above. Now if john only exists as the key of WeakMap – it will be automatically deleted from the map (and memory).
WeakMap does not support iteration and methods keys(), values(), entries(), so there’s no way to get all keys or values from it.
WeakMap has only the following methods:
weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)

->WeakSet
WeakSet behaves similarly:
It is analogous to Set, but we may only add objects to WeakSet (not primitives).
An object exists in the set while it is reachable from somewhere else.
Like Set, it supports add, has and delete, but not size, keys() and no iterations.

21).Object.keys, values, entries
For plain objects, the following methods are available:

Object.keys(obj) – returns an array of keys.
Object.values(obj) – returns an array of values.
Object.entries(obj) – returns an array of [key, value] pairs.

21).Date and time
Let’s meet a new built-in object: Date. It stores the date, time and provides methods for date/time management.
we can use it to store creation/modification times, to measure time, or just to print out the current date.
Creation
Greenwich Mean Time (GMT) is often interchanged or confused with Coordinated Universal Time (UTC). But GMT is a time zone and UTC is a time standard.
 The Royal Observatory in the UK. The Royal Observatory in Greenwich, London, United Kingdom.
To create a new Date object call new Date() with one of the following arguments:
->new Date()
Without arguments – create a Date object for the current date and time:
->new Date(milliseconds)
Create a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.
->new Date(datestring)
If there is a single argument, and it’s a string, then it is parsed automatically. The algorithm is the same as Date.parse uses, we’ll cover it later.
->Setting date components
->The following methods allow to set date/time components:
setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)
->new Date(year, month, date, hours, minutes, seconds, ms)
Create the date with the given components in the local time zone. Only the first two arguments are obligatory.
The year must have 4 digits: 2013 is okay, 98 is not.
The month count starts with 0 (Jan), up to 11 (Dec).
The date parameter is actually the day of month, if absent then 1 is assumed.
If hours/minutes/seconds/ms is absent, they are assumed to be equal 0.
/*
new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // the same, hours etc are 0 by default
*/
The minimal precision is 1 ms (1/1000 sec):.
->Access date components
There are methods to access the year, month and so on from the Date object:
getFullYear()
Get the year (4 digits)
getMonth()
Get the month, from 0 to 11.
getDate()
Get the day of month, from 1 to 31, the name of the method does look a little bit strange.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Get the corresponding time components.
->getDay()
Get the day of week, from 0 (Sunday) to 6 (Saturday). The first day is always Sunday, in some countries that’s not so, but can’t be changed.
->Besides the given methods, there are two special ones that do not have a UTC-variant:
->getTime()
Returns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.
->getTimezoneOffset()
Returns the difference between the local time zone and UTC, in minutes:
/*
// if you are in timezone UTC-1, outputs 60
// if you are in timezone UTC+3, outputs -180
alert( new Date().getTimezoneOffset() );
*/
->Autocorrection
The autocorrection is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.
/*
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...is 1st Feb 2013!
*/
->Date.now()
If we only want to measure time, we don’t need the Date object.
There’s a special method Date.now() that returns the current timestamp.
It is semantically equivalent to new Date().getTime(), but it doesn’t create an intermediate Date object. So it’s faster and doesn’t put pressure on garbage collection.
It is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.
->Date.parse from a string
The method Date.parse(str) can read a date from a string.
The string format should be: YYYY-MM-DDTHH:mm:ss.sssZ, where:
YYYY-MM-DD – is the date: year-month-day.
The character "T" is used as the delimiter.
HH:mm:ss.sss – is the time: hours, minutes, seconds and milliseconds.
The optional 'Z' part denotes the time zone in the format +-hh:mm. A single letter Z that would mean UTC+0.
Shorter variants are also possible, like YYYY-MM-DD or YYYY-MM or even YYYY.
The call to Date.parse(str) parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns NaN.
->Summary
Date and time in JavaScript are represented with the Date object. We can’t create “only date” or “only time”: Date objects always carry both.
Months are counted from zero (yes, January is a zero month).
Days of week in getDay() are also counted from zero (that’s Sunday).
Date auto-corrects itself when out-of-range components are set. Good for adding/subtracting days/months/hours.
Dates can be subtracted, giving their difference in milliseconds. That’s because a Date becomes the timestamp when converted to a number.
Use Date.now() to get the current timestamp fast.

22).JSON methods, toJSON
->JSON.stringify
The JSON (JavaScript Object Notation) is a general format to represent values and objects. It is described as in RFC 4627 standard.
Initially it was made for JavaScript, but many other languages have libraries to handle it as well.
So it’s easy to use JSON for data exchange when the client uses JavaScript and the server is written on Ruby/PHP/Java/Whatever.
->JavaScript provides methods:
JSON.stringify to convert objects into JSON.
JSON.parse to convert JSON back into an object.
json string is called a JSON-encoded or serialized or stringified or marshalled object. We are ready to send it over the wire or put into a plain data store.
Strings use double quotes. No single quotes or backticks in JSON. So 'John' becomes "John".
Object property names are double-quoted also. That’s obligatory. So age:30 becomes "age":30.
->Excluding and transforming: replacer
let json = JSON.stringify(value[, replacer, space])
->value
A value to encode.
->replacer
Array of properties to encode or a mapping function function(key, value).
->space
Amount of space to use for formatting
Most of the time, JSON.stringify is used with the first argument only. But if we need to fine-tune the replacement process,
 like to filter out circular references, we can use the second argument of JSON.stringify.
If we pass an array of properties to it, only these properties will be encoded.
->Formatting: space
The third argument of JSON.stringify(value, replacer, space) is the number of spaces to use for pretty formatting.
Previously, all stringified objects had no indents and extra spaces. That’s fine if we want to send an object over a network. 
The space argument is used exclusively for a nice output.
Here space = 2 tells JavaScript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:
->Custom “toJSON”
Like toString for string conversion, an object may provide method toJSON for to-JSON conversion. JSON.stringify automatically calls it if available.
->JSON.parse
To decode a JSON-string, we need another method named JSON.parse.
->Summary
JSON is a data format that has its own independent standard and libraries for most programming languages.
JSON supports plain objects, arrays, strings, numbers, booleans, and null.
JavaScript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.
Both methods support transformer functions for smart reading/writing.
If an object has toJSON, then it is called by JSON.stringify.
************* Advanced working with functions ***************
23).Recursion and stack
Recursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler.
Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we’ll see soon, to deal with certain data structures.
When a function solves a task, in the process it can call many other functions. A partial case of this is when a function calls itself. That’s called recursion.
->Two ways of thinking
For something simple to start with – let’s write a function pow(x, n) that raises x to a natural power of n. In other words, multiplies x by itself n times.
->Iterative thinking: the for loop:
->Recursive thinking: simplify the task and call self:
24)Rest parameters and spread operator
->Rest parameters ...
A function can be called with any number of arguments, no matter how it is defined.
There will be no error because of “excessive” arguments. But of course in the result only the first two will be counted.
The rest of the parameters can be included in the function definition by using three dots ... followed by the name of the array that will contain them. 
The dots literally mean “gather the remaining parameters into an array”.
Here the first two arguments go into variables and the rest go into titles array:
25)Closure
JavaScript is a very function-oriented language. It gives us a lot of freedom. A function can be created dynamically,
 copied to another variable or passed as an argument to another function and called from a totally different place later.
We know that a function can access variables outside of it, this feature is used quite often.
But what happens when an outer variable changes? Does a function get the most recent value or the one that existed when the function was created?
26)Global object
The global object provides variables and functions that are available anywhere. By default, those that are built into the language or the environment.
In a browser it is named window, for Node.js it is global, for other environments it may have another name.
Recently, globalThis was added to the language, as a standardized name for a global object, that should be supported across all environments.
 In some browsers, namely non-Chromium Edge, globalThis is not yet supported, but can be easily polyfilled.
We’ll use window here, assuming that our environment is a browser. If your script may run in other environments, it’s better to use globalThis instead.
->In a browser, global functions and variables declared with var (not let/const!) become the property of the global object:
27)Function object, NFE
In JavaScript, functions are objects.
A good way to imagine functions is as callable “action objects”. We can not only call them, but also treat them as objects: add/remove properties, pass by reference etc.
->The “name” property
Function objects contain some useable properties.
a function’s name is accessible as the “name” property:
/*
function sayHi() {
  alert("Hi");
}
alert(sayHi.name); // sayHi
*/
->The “length” property
There is another built-in property “length” that returns the number of function parameters.
->Custom properties
We can also add properties of our own.
Here we add the counter property to track the total calls count:
->Named Function Expression
Named Function Expression, or NFE, is a term for Function Expressions that have a name.
let’s take an ordinary Function Expression:
Did we achieve anything here? What’s the purpose of that additional "func" name?
First let’s note, that we still have a Function Expression. Adding the name "func" after function did not make it a Function Declaration, because it is still created as a part of an assignment expression.
Adding such a name also did not break anything.
->There are two special things about the name func, that are the reasons for it:
It allows the function to reference itself internally.
It is not visible outside of the function.
Sometimes, when we need a reliable internal name, it’s the reason to rewrite a Function Declaration to Named Function Expression form
28)The "new Function" syntax
There’s one more way to create a function. It’s rarely used, but sometimes there’s no alternative.
/*
let func = new Function ([arg1, arg2, ...argN], functionBody);
*/
/*
let sum = new Function('a', 'b', 'return a + b');
alert( sum(1, 2) ); // 3
*/
new Function allows to turn any string into a function. For example, we can receive a new function from a server and then execute it:
/*
let str = ... receive the code from a server dynamically ...
let func = new Function(str);
func();
*/
It is used in very specific cases, like when we receive code from a server, or to dynamically compile a function from a template, in complex web-applications.
->Closure
Usually, a function remembers where it was born in the special property [[Environment]]. It references the Lexical Environment from where it’s created (we covered that in the chapter Closure).
But when a function is created using new Function, its [[Environment]] is set to reference not the current Lexical Environment, but the global one.
So if new Function had access to outer variables, it would be unable to find renamed userName.
If new Function had access to outer variables, it would have problems with minifiers.
Besides, such code would be architecturally bad and prone to errors.
To pass something to a function, created as new Function, we should use its arguments.
29)Scheduling: setTimeout and setInterval
We may decide to execute a function not right now, but at a certain time later. That’s called “scheduling a call”.
*There are two methods for it:
->setTimeout allows us to run a function once after the interval of time.
->setInterval allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.
These methods are not a part of JavaScript specification. But most environments have the internal scheduler and provide these methods. In particular, they are supported in all browsers and Node.js.
->setTimeout
/*
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
*/
->func|code
Function or a string of code to execute. Usually, that’s a function. For historical reasons, a string of code can be passed, but that’s not recommended.
->delay
The delay before run, in milliseconds (1000 ms = 1 second), by default 0.
->arg1, arg2…
Arguments for the function (not supported in IE9-)
->Pass a function, but don’t run it
Novice developers sometimes make a mistake by adding brackets () after the function:
/*
// wrong!
setTimeout(sayHi(), 1000);
*/
That doesn’t work, because setTimeout expects a reference to a function. And here sayHi() runs the function, and the result of its execution is passed to setTimeout.
 In our case the result of sayHi() is undefined (the function returns nothing), so nothing is scheduled.
->Canceling with clearTimeout
A call to setTimeout returns a “timer identifier” timerId that we can use to cancel the execution.
/*
let timerId = setTimeout(...);
clearTimeout(timerId);
*/
In the code below, we schedule the function and then cancel it (changed our mind). As a result, nothing happens:
/*
 let timerId = setTimeout(() => alert("never happens"), 1000);
alert(timerId); // timer identifier
clearTimeout(timerId);
alert(timerId); // same identifier (doesn't become null after canceling)
*/
As we can see from alert output, in a browser the timer identifier is a number. In other environments, this can be something else. For instance, Node.js returns a timer object with additional methods.
->setInterval
The setInterval method has the same syntax as setTimeout:
/*
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
*/
All arguments have the same meaning. But unlike setTimeout it runs the function not only once, but regularly after the given interval of time.
To stop further calls, we should call clearInterval(timerId).
The following example will show the message every 2 seconds. After 5 seconds, the output is stopped:

30)Function binding
When passing object methods as callbacks, for instance to setTimeout, there’s a known problem: "losing this".
->Losing “this”
We’ve already seen examples of losing this. Once a method is passed somewhere separately from the object – this is lost.
Here’s how it may happen with setTimeout:
As we can see, the output shows not “John” as this.firstName, but undefined!
That’s because setTimeout got the function user.sayHi, separately from the object. The last line can be rewritten as:
The method setTimeout in-browser is a little special: it sets this=window for the function call (for Node.js, this becomes the timer object, but doesn’t really matter here).
 So for this.firstName it tries to get window.firstName, which does not exist. In other similar cases, usually this just becomes undefined. 

31)Arrow functions revisited
Let’s revisit arrow functions.
Arrow functions are not just a “shorthand” for writing small stuff. They have some very specific and useful features.
JavaScript is full of situations where we need to write a small function that’s executed somewhere else.
->arr.forEach(func) – func is executed by forEach for every array item.
->setTimeout(func) – func is executed by the built-in scheduler.
It’s in the very spirit of JavaScript to create a function and pass it somewhere.
And in such functions we usually don’t want to leave the current context. That’s where arrow functions come in handy.
->Arrow functions:
Do not have this
Do not have arguments
Can’t be called with new
They also don’t have super, but we didn’t study it yet. We will on the chapter Class inheritance
That’s because they are meant for short pieces of code that do not have their own “context”, but rather work in the current one. And they really shine in that use case.

32)Property flags and descriptors
As we know, objects can store properties.
Until now, a property was a simple “key-value” pair to us. But an object property is actually a more flexible and powerful thing.
In this chapter we’ll study additional configuration options, and in the next we’ll see how to invisibly turn them into getter/setter functions.
->Property flags
Object properties, besides a value, have three special attributes (so-called “flags”):
-writable – if true, the value can be changed, otherwise it’s read-only.
-enumerable – if true, then listed in loops, otherwise not listed.
-configurable – if true, the property can be deleted and these attributes can be modified, otherwise not.
We didn’t see them yet, because generally they do not show up. When we create a property “the usual way”, all of them are true. But we also can change them anytime.
->The method Object.getOwnPropertyDescriptor allows to query the full information about a property.
/*
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
*/
-> Object.defineProperty.
If the property exists, defineProperty updates its flags. Otherwise, it creates the property with the given value and flags; in that case, if a flag is not supplied, it is assumed false.
For instance, here a property name is created with all falsy flags:
->To change the flags, we can use Object.defineProperty.
/*
Object.defineProperty(obj, propertyName, descriptor)
*/

33)Property getters and setters
The second type of properties is something new. It’s accessor properties. They are essentially functions that work on getting and setting a value,
 but look like regular properties to an external code.
->Getters and setters
Accessor properties are represented by “getter” and “setter” methods. In an object literal they are denoted by get and set:
/*
let obj = {
  get propName() {
    // getter, the code executed on getting obj.propName
  },

  set propName(value) {
    // setter, the code executed on setting obj.propName = value
  }
};
*/
->Accessor descriptors
Descriptors for accessor properties are different from those for data properties.
For accessor properties, there is no value or writable, but instead there are get and set functions.
That is, an accessor descriptor may have:
get – a function without arguments, that works when a property is read,
set – a function with one argument, that is called when the property is set,
enumerable – same as for data properties,
configurable – same as for data properties.
For instance, to create an accessor fullName with defineProperty, we can pass a descriptor with get and set:
->Smarter getters/setters
Getters/setters can be used as wrappers over “real” property values to gain more control over operations with them.
For instance, if we want to forbid too short names for user, we can have a setter name and keep the value in a separate property _name:

34)Prototypal inheritance
In programming, we often want to take something and extend it.
For instance, we have a user object with its properties and methods, and want to make admin and guest as slightly modified variants of it.
 We’d like to reuse what we have in user, not copy/reimplement its methods, just build a new object on top of it.
Prototypal inheritance is a language feature that helps in that.